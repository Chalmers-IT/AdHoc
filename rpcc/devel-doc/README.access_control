
Method access control - the Guard, @entry and Privilege.

Access control decisions are normally made based on the presence or
absence of particular Privileges in the Session (call context) in
which a call is made.

All remote calls start in a Function instance, which calls one or more
methods on Models, Managers, Matches and other internal objects. The
methods called may in turn call other methods - and so on.

Common to all methods is that when they are called they - somehow -
have access to the Function in which the call chain started.

To enable access control on individual methods, they can be decorated
with the @entry decorator, which has a Guard associated with it. When
a call is made to an @entry-decorated method, the Guard makes an
access decision. If the decision is AccessGranted, the decision is
noted in the Function. @entry-decorated methods further down the call
chain will let the call through unchallenged.

When the call finishes, the @entry decorator removes the access
decision from the Function, so that the first @entry decorator in
any parallell call chain will get to make a decision.

By this, the @entry decorators form a perimeter around the data model.


The idea is that any method on Model, Manager or Match should be
@entry-able.


* Template methods

  @template-decorated methods on Models are called to add templated
  data. If they are also decorated by an @entry, access control can be
  made on a per-object and/or per-attribute basis.

* Update methods

  @update-decorated methods on Models are called when an update call
  is made. If they are also decorated by an @entry, per-object and/or
  per-attribute access control is possible.

* Search methods

  @search-decorated methods on Managers are called when an incoming
  call speficies a search key related to a particular searchable
  attribute. If they are also decorated by an @entry, per-attribute
  search privileges can be controlled (regardless of match type). This
  can for example require a Privilege to search on personnummer.

* Match methods

  @prefix/@suffix-decorated methods on Match subclasses are called
  when an incoming call specifies a search key related to that
  method's matching type. If also decorated by an @entry, then 
  per-match-type access control is possible. For example a Privilege
  can be required to perform regexp matching.

* Other methods

  If the server uses other objects, that are neither Models, Managers
  nor Matches, it should still be possible to @entry-decorate methods
  in them. The only requirement for this to work is that the Guard can
  get at the Function.

  If the guarded object is one of the standard classes, @entry knows
  how to extract the function from them. If not, the guarded object
  must implement a method called "get_entry_function" which returns
  the Function.

  Objects that do not have the Function instance available to them
  cannot be guarded.



Guard caching.

In order for objects to more efficiently handle large _dig() calls,
responses from individual Guards should be cache:able. This is
especially important when using long Chain:s of guards. But some
Guards guard the object as a whole, some guard the method as a whole,
and some guard a combination of a particular object and a particular
method.

* If it is a per-object Guard, the decision could be cached in the
  object (since the Function should have access on some objects but
  not on others). 

* If it is a per-attribute Guard, the decision could be cached in the
  Function, since it should always have access to the attribute
  regardless of object. There is no harm in storing it in the object,
  it just doesn't do any good. 

* If it is a per-class Guard (as for Match methods), however, the
  response cannot be cached in in the class, since classes are global
  and not Function-local as the Models and Managers are. And if it's
  in a user-defined object, you don't know whether it's global or
  Function-local.

The obvious solution is for the @entry to keep a Guard decision cache
in the Function. But sometimes that should be indexed just by Guard
(attribute access) and sometimes by object/class and Guard. The Guard
might tell which - if it knows.

It would be easier to say that if a Guard performs a complex check, it
will have to take care of the caching itself. But the Guards that gain
the most from caching are Chain:s with many sub-Guards, and the Chain
won't know.


Perhaps guards can return caching information with their response?
Whatever they return, a .cache attribute could determines whether the
response is cacheable or not, and where it can be cached?

* If the same response will always be given for the same session (such
  as a plain PrivilegeGuard), it can be cached in the session. Perhaps
  this level of cacheing is unnecessary?

* If the same response will always be returned for the same Function
  instance, cacheability is "function".

* A Guard which uses methods on the object being guarded to make its
  decision, can (often) have that decision cached in the object. It's
  cacheability is in that case "object".

* Other Guards cannot be cached at all. Their cacheability is "None".

A Chain will look at return values of sub-guards. It will return the
minimum cacheability of any sub-guard's response, where "None" is the
"least".





