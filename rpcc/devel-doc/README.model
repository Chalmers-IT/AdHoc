
Model objects represent some "thing" in the system. 

Ultimate goal: from definitions on the Model and Manager,
auto-generate _dig(), _fetch() and _update() calls.


Lets start with _fetch(), which takes an object id and a data
template, and produces templated data for that particular object.

The first problem is "who" defines the date template and templated
data structures (ExtStruct:s).

The reasonable place to define which attributes the template can
contain, are in the Model class. An example would be an
@extattr(exttype) decorator on a get_foo() method to define a "foo"
template attribute of type "exttype".

But who should be responsible for generating the template structures?

The template structure is only meaningful in the context of a _fetch()
or _dig() function, and these functions should be
auto-generated. The templates could then be generated by whoever
generates the function, by the generated function, or by the Model
object itself.

* Templates act one-to-one with a Model. [model]
* It is never meaningful to create just one Model's template since
  they reference each other. [model+other]
* Templates are applied by Model instances. [model]


From the top:

* Models are registered with the Server instance, under a name.

* For each Model, the Server generates Function subclasses for
  name_dig(), name_fetch() and name_update().

* In order to do this, each Model is asked to generate its own
  DataTemplate, TemplatedData, SearchOptions and UpdateOptions.

* DataTemplate/TemplatedData/SearchOptions reference other Model
  classes' such structures. These references has a standard
  format. The Server generates the structures for all Models, then
  links them together to form complete structs.

* The auto-gen is always done in the context of one particular API
  version, and therefore the API object is the natural place to do
  this.


When applying a template:

* One very important optimization is that, for example, many different
  Group instances generate subtemplates for the same Account
  instances.

* If the @template has type ExtOrNull(something), the client can have
  the key removed if the value would have been null by specifying
  _remove_nulls=True in the template. The default is False.

* If the @template has type ExtOrNull(something) _and_ a model, the
  output type will be ExtOrNull(subtemplate_data), and _remove_nulls
  applies as above. So if the method returns a Model instance, the
  subdata is included, if it returns None then either None is returned
  or the key is removed.

* _remove_nulls is inherited into subtemplates not having their own
  value for it.


