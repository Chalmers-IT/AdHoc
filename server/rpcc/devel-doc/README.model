
Model objects represent some "thing" in the system. 

Ultimate goal: from definitions on the Model and Manager,
auto-generate _dig(), _fetch() and _update() calls.


Lets start with _fetch(), which takes an object id and a data
template, and produces templated data for that particular object.

The first problem is "who" defines the data template and templated
data structures (ExtStruct:s).

The reasonable place to define which attributes the template can
contain, are in the Model class. An example would be an
@extattr(exttype) decorator on a get_foo() method to define a "foo"
template attribute of type "exttype".

But who should be responsible for generating the template structures?

The template structure is only meaningful in the context of a _fetch()
or _dig() function, and these functions should be
auto-generated. The templates could then be generated by whoever
generates the function, by the generated function, or by the Model
object itself.

* Templates act one-to-one with a Model. [model]
* It is never meaningful to create just one Model's template since
  they reference each other. [model+other]
* Templates are applied by Model instances. [model]


From the top:

* Models are registered with the Server instance, under a name.

* For each Model, the Server generates Function subclasses for
  name_dig(), name_fetch() and name_update().

* In order to do this, each Model is asked to generate its own
  DataTemplate, TemplatedData, SearchOptions and UpdateOptions.

* DataTemplate/TemplatedData/SearchOptions reference other Model
  classes' such structures. These references has a standard
  format. The Server generates the structures for all Models, then
  links them together to form complete structs.

* The auto-gen is always done in the context of one particular API
  version, and therefore the API object is the natural place to do
  this.


When applying a template:

* One very important optimization is that, for example, many different
  Group instances generate subtemplates for the same Account
  instances.

* If the @template has type ExtOrNull(something), the client can have
  the key removed if the value would have been null by specifying
  _remove_nulls=True in the template. The default is False.

* If the @template has type ExtOrNull(something) _and_ a model, the
  output type will be ExtOrNull(subtemplate_data), and _remove_nulls
  applies as above. So if the method returns a Model instance, the
  subdata is included, if it returns None then either None is returned
  or the key is removed.

* _remove_nulls is inherited into subtemplates not having their own
  value for it.


Searches:

* There is a number of Match subclasses, for example StringMatch. Each
  Match subclass has a number of matching methods, identified by
  @prefix()/@suffix(). 

* Each Manager subclass has a number of search parameters, identified
  by @search(extname, match_class).

* On startup, each Manager class is asked to generate its search keys
  and return an ExtStruct instance. For every attribute ("firstname")
  it asks the Match class for keys (getting e.g. "firstname_equals"
  back) with their exttypes and their methods. It fills the search
  struct with keys and exttypes, and keeps the keys and Match methods,
  together with the own method.

  The ExtStruct values can be _TmpReference(name) as in templates.

* When searching, a Manager starts by creating a random result id, and
  setting that up in the RPCC_RESULT_SET table, with columns for id,
  expiry time and manager name.

  It then creates a Query, which selects ID:s into RPCC_RESULT_STRING
  or RPCC_RESULT_INTEGER. 

  For each incoming search key, it calls its own method (the one that
  was decorated with @search) to set up the Query, then calls the
  Match method passing the return value from the own setup method. The
  Match method further adds to the Query.

  The Manager then executes the Query, and returns the result id to
  the callers.

* Managers' instantiation methods should always accept a single ID or
  a resultset=<id> keyword and act resonably.

* For subsearches, apart from the keys generated by the Match:er, the
  special key "<attr>_in" is also created and bound to the Manager
  that manages the subsearch.

  When a subsearch comes in, the outer manager creates a DynamicQuery
  as usual. When adding the subquery, the DynamicQuery is asked for a
  sub-query. The sub-dynamic-query is then used to build the subquery.



